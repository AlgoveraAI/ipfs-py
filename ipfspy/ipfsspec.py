# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_ipfsspec.ipynb (unless otherwise specified).

__all__ = ['IPFSGateway', 'IPFSFileSystem']

# Cell
from os.path import isdir
from typing import Union, List
import json
import random
import time
import requests
import pandas as pd
import imageio
from io import StringIO,BytesIO
from requests.exceptions import HTTPError
from fsspec.spec import AbstractFileSystem
from ipfsspec.core import IPFSBufferedFile
from ipfshttpclient.multipart import stream_files, stream_directory

# Cell
from .utils import GATEWAYS_API_READ, GATEWAYS_API_WRITE, parse_error_message, parse_response, get_coreurl

# Cell
class IPFSGateway:
    def __init__(self,
        local:bool=True, # Use local IPFS deamon or not
        coreurl:str=None, # Core URL of an alterative gateways to use
    ):
        'Starts a IPFS Gateway either using local node or infura. If given `coreurl`, will use that for the gateway'
        self.coreurl = coreurl
        if self.coreurl is None:
            self.url = self.get_gateway(local=local)

        else:
            self.url = self.get_gateway(coreurl=coreurl)

        self.session = requests.Session()
        adapter = requests.adapters.HTTPAdapter(pool_connections=100, pool_maxsize=100)
        self.session.mount('http://', adapter)
        self.session.mount('https://', adapter)

    def get_gateway(self,
        local:bool=True, # If local uses local node, else uses Infura.io gateway
        coreurl:str=None, # URL of other gateways
    ):
        'Set the core url for convenience'

        return get_coreurl(local=local, coreurl=coreurl)


    def get(self,
        cid:str, # Path to the IPFS object
        **kwargs
    ):
        'Get a file/directory from IPFS'

        params = {}
        params['arg'] = cid
        params.update(kwargs)

        res = self.session.post(f'{self.url}/get', params=params)

        if res.status_code == 200:
            return res, parse_response(res)

        else:
            raise HTTPError (parse_error_message(res))

    def cat(self,
        cid:str, # Path to the IPFS object
        **kwargs
    ):
        'Read a file from IPFS'

        params = {}
        params['arg'] = cid
        params.update(kwargs)

        res = self.session.post(f'{self.url}/cat', params=params)

        if res.status_code == 200:
            return res, res.text

        else:
            if res.status_code == 500:
                raise TypeError (f"dag node {path} is a directory; Provide a file CID")
            else:
                raise HTTPError (parse_error_message(res))

    def apipost(self,
        call:str, # The call type to post e.g. 'add', 'ls', 'pin/add', 'pin/ls'
        filepath:Union[str, List[str]]=None, # Path to files or directory or IPFS Path
        directory:bool=False, # Is filepath a directory
        chunk_size=200000, # Chunk size to use
        **kwargs):
        'Makes `post` call to the HTTP APPI'


        if call == 'add':
            if isdir(filepath):
                if directory == False:
                    raise TypeError (f"{filepath} is a directory. Set arg directory as True")

            params = {}
            params.update(kwargs)

            if not directory:
                data, headers = stream_files(filepath, chunk_size=chunk_size)

            else:
                data, headers = stream_directory(filepath, chunk_size=chunk_size)

            res = self.session.post(f'{self.url}/add',
                                     params=params,
                                     data=data,
                                     headers=headers)

            if res.status_code == 200:
                return res, parse_response(res)

            else:
                raise HTTPError (parse_error_message(res))

        else:
            params = {}
            params['arg'] = filepath
            params.update(kwargs)

            res = self.session.post(f'{self.url}/{call}', params=params)

            if res.status_code == 200:
                return res, parse_response(res)

            else:
                raise HTTPError (parse_error_message(res))

    def head(self,
        cid:str, # Path to the IPFS object
        headers=None,
        **kwargs
    ):

        res,_ = self.get(cid)

        return res.headers

# Cell
class IPFSFileSystem(AbstractFileSystem):
    protocol = "ipfs"
    def __init__(self,
        local=True, # Use local IPFS deamon or not
        coreurl:str=None, # Core URL of an alterative gateways to use
        **kwargs):
        'fsspec like read/write IPFS filesystem'

        super(IPFSFileSystem, self).__init__(local, **kwargs)

        if coreurl is None:
            self.gw = IPFSGateway(local=local)

        else:
            self.gw = IPFSGateway(coreurl)

    def ls(self,
        cid:str, # Path of the IPFS object
        detail=True, # Verbose
        **kwargs):
        'List the links of a IPFS file/directory'

        _, res = self.gw.apipost("ls", arg=cid)

        links = res[0]["Objects"][0]["Links"]
        types = {1: "directory", 2: "file"}

        if detail:
            return [{"name": cid + "/" + link["Name"],
                     "size": link["Size"],
                     "type": types[link["Type"]]}
                    for link in links]

        else:
            return [cid + "/" + link["Name"]
                    for link in links]

    def cat_file(self,
        cid:str, # Path of the IPFS object
    ):

        r, data = self.gw.cat(cid)

        return r.content

    def _open(
        self,
        cid, # Path of the IPFS object
        mode="rb",
        block_size=None,
        autocommit=True,
        cache_options=None,
        **kwargs
    ):
        'Return raw bytes-mode file-like from the file-system'

        return IPFSBufferedFile(
            self,
            cid,
            mode,
            block_size,
            autocommit,
            cache_options=cache_options,
            **kwargs
        )

    def info(self,
        cid, # Path of the IPFS object
        **kwargs):

        path = self._strip_protocol(cid)

        headers = {"Accept-Encoding": "identity"}  # this ensures correct file size
        response_headers = self.gw.head(cid, headers)

        info = {"name": cid}
        if "X-Content-Length" in response_headers:
            info["size"] = int(response_headers["X-Content-Length"])
        elif "X-Content-Range" in response_headers:
            info["size"] = int(response_headers["X-Content-Range"].split("/")[1])

        if "ETag" in response_headers:
            etag = response_headers["ETag"].strip("\"")
            info["ETag"] = etag
            if etag.startswith("DirIndex"):
                info["type"] = "directory"
                info["CID"] = etag.split("-")[-1]
            else:
                info["type"] = "file"
                info["CID"] = etag
        return info

    def write(self,
        filepath, # Path to file/files/directories to write to IPFS
        directory=False, # Is filepath a directory
        chunk_size=200000, # Chunk size to use
        **kwargs
    ):
        'Write the given file/files/directories to the IPFS network'

        return self.gw.apipost('add', filepath=filepath, directory=directory, chunk_size=chunk_size, **kwargs)

    def read_csv(self,
        cid:str,
        delimeter:str=','
    ):
        r, data = self.gw.cat(cid)

        return pd.read_csv(StringIO(data), delimiter=delimeter)

    def read_json(self,
        cid:str,
    ):
        r, data = self.gw.cat(cid)

        return pd.read_json(StringIO(data))

    def read_image(self,
        cid:str,
    ):
        data = self.cat_file(cid)

        return imageio.v2.imread(BytesIO(data))